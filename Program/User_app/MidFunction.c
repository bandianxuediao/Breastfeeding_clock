#include "includes.h"

//MEASURE_STR measure_str;

//OPERATE_DATA op_data;
//LOGGER_INFO logger_info;
//u8 temp_buffer[1056];//用于全局的中间缓冲区，非专用。
u8 INPUT_PASS_STATE ; //用于表示处在哪个密码输入状态

SYS_STATE Detect_Pin_State(void)
{
	if(PIN10)
	{
		delay_ms(200);

		if(PIN10)
		{
			return KEY_UP;
		}
	}

	if(PIN11)
	{
		delay_ms(200);

		if(PIN11)
		{
			return KEY_DOWN;
		}
	}

	if(PIN12)
	{
		delay_ms(200);

		if(PIN12)
		{
			return KEY_SET;
		}
	}

	return 0;
}

void PIN_Init(void)
{
	GPIO_InitTypeDef GPIO_InitStructure;
	RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOA, ENABLE ); //使能GPIOA时钟
	RCC_APB2PeriphClockCmd( RCC_APB2Periph_AFIO, ENABLE );

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP ;   //推挽输出
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
	GPIO_SetBits(GPIOA, GPIO_Pin_15);   //PB12 输出高电平,检测红外电平

	RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOB, ENABLE ); //使能GPIOB时钟

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD ;   //上拉输入
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
	//GPIO_SetBits(GPIOB,GPIO_Pin_12);  //PB12 输出高电平,检测红外电平


	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);//PB 0,1,3,4用于12864的控制引脚
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_Init(GPIOB, &GPIO_InitStructure);



}

u8 compare_array(u8* array1, u8* array2)
{
	int i;

	for(i = 0;; i < 1)
	{

		if(array1[i] != array2[i])
			return 0;

		i++;
	}

	return 1;
}




//==================================================================================================
//| 函数名称 | U32DataCMP
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 比较指定缓冲区中的数据(32位数据),返回最大相差值
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | ptr:需要比较的数据缓冲区首址
//|          | length:需要比较的数据缓冲区长度
//|----------|--------------------------------------------------------------------------------------
//| 返回参数 | 缓冲区中数据最大相差值
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | 编写人：李亚东    时间：2016-08-25
//|----------|--------------------------------------------------------------------------------------
//|   备注   |
//|----------|--------------------------------------------------------------------------------------
//| 修改记录 | 修改人：          时间：         修改内容：
//==================================================================================================
u32 U32DataCMP(const u32* ptr, u8 length)
{
	u32 max_value, min_value ;
	u8 i ;

	max_value = *ptr; //最大值
	min_value = *ptr; //最小值

	for(i = 1; i < length; i++)
	{
		if(*(ptr + i) > max_value)
		{
			max_value = *(ptr + i) ;
		}
		else if(*(ptr + i) < min_value)
		{
			min_value = *(ptr + i) ;
		}
	}

	return (max_value - min_value); //返回相差值
}

//==================================================================================================
//| 函数名称 | U16DataCMP
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 比较指定缓冲区中的数据(16位数据),返回最大相差值
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | ptr:需要比较的数据缓冲区首址
//|          | length:需要比较的数据缓冲区长度
//|----------|--------------------------------------------------------------------------------------
//| 返回参数 | 缓冲区中数据最大相差值
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | 编写人：李亚东    时间：2016-08-25
//|----------|--------------------------------------------------------------------------------------
//|   备注   |
//|----------|--------------------------------------------------------------------------------------
//| 修改记录 | 修改人：          时间：         修改内容：
//==================================================================================================
u16 U16DataCMP(const u16* ptr, u8 length)
{
	u16 max_value, min_value ;
	u8 i ;

	max_value = *ptr; //最大值
	min_value = *ptr; //最小值

	for(i = 1; i < length; i++)
	{
		if(*(ptr + i) > max_value)
		{
			max_value = *(ptr + i) ;
		}
		else if(*(ptr + i) < min_value)
		{
			min_value = *(ptr + i) ;
		}
	}

	return (max_value - min_value); //返回相差值
}

//==================================================================================================
//| 函数名称 | GetU16DataMax
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 对一组数据(16位)求最大值
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | ptr 指针，指要求平均值的数据
//|          | lenght数据个数
//|----------|--------------------------------------------------------------------------------------
//| 返回参数 | 最大值
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | 编写人：李亚东    时间：2016-08-25
//|----------|--------------------------------------------------------------------------------------
//|   备注   |
//|----------|--------------------------------------------------------------------------------------
//| 修改记录 | 修改人：          时间：         修改内容：
//==================================================================================================
u16 GetU16DataMax(const u16* ptr, u8 length)
{
	u16 max_value = 0;
	u8 i ;

	max_value = *ptr; //最大值

	for(i = 1; i < length; i++)
	{
		if(*(ptr + i) > max_value)
		{
			max_value = *(ptr + i) ;
		}
	}

	return max_value ;  //返回最大值
}

//==================================================================================================
//| 函数名称 | GetU16DataMin
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 对一组数据(16位)求最小值
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | ptr 指针，指要求平均值的数据
//|          | lenght数据个数
//|----------|--------------------------------------------------------------------------------------
//| 返回参数 | 最小值
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | 编写人：李亚东    时间：2016-08-25
//|----------|--------------------------------------------------------------------------------------
//|   备注   |
//|----------|--------------------------------------------------------------------------------------
//| 修改记录 | 修改人：          时间：         修改内容：
//==================================================================================================
u16 GetU16DataMin(const u16* ptr, u8 length)
{
	u16 min_value = 0 ;
	u8 i ;

	min_value = *ptr; //最小值

	for(i = 1; i < length; i++)
	{
		if(*(ptr + i) < min_value)
		{
			min_value = *(ptr + i) ;
		}
	}

	return min_value ;  //返回最小值
}

//==================================================================================================
//| 函数名称 | GetU16DataAverage
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 对数据(16位)求平均值
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | ptr 指针，指要求平均值的数据
//|          | lenght数据个数
//|----------|--------------------------------------------------------------------------------------
//| 返回参数 | 平均值
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | 编写人：李亚东    时间：2016-08-25
//|----------|--------------------------------------------------------------------------------------
//|   备注   |
//|----------|--------------------------------------------------------------------------------------
//| 修改记录 | 修改人：          时间：         修改内容：
//==================================================================================================
u16 GetU16DataAverage(u16* ptr, u16 lenght)
{
	u16 i;
	u32 sum = 0;

	for(i = 0; i < lenght; i++)
	{
		sum += *ptr++;
	}

	if(lenght != 0)
	{
		sum /= lenght ;
	}

	return (u16)sum;
}



